rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper to check if current user is an approved police officer.
    // Police profiles live in /police/{uid} with fields: uid, role == 'police', isApproved == true
    function isPolice() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/police/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/police/$(request.auth.uid)).data.role == 'police' &&
             get(/databases/$(database)/documents/police/$(request.auth.uid)).data.isApproved == true;
    }
    
    // USERS COLLECTION
    // Modified to allow custom document IDs (Dharma_Name_Date) 
    // by checking the 'uid' field inside the document instead of the document name.
    match /users/{userId} {
      // ⭐ Police/Admin = full control
      allow read, update, delete: if isPolice();

      // ⭐ Citizen = only own data
      // CHANGED: 'get' to 'read' to allow queries (collection.where('uid', ==, ...))
      allow read: if request.auth != null &&
        resource.data.uid == request.auth.uid;

      allow create: if request.auth != null &&
        request.resource.data.uid == request.auth.uid;

      allow update: if request.auth != null &&
        resource.data.uid == request.auth.uid;
    }

    // POLICE COLLECTION (for police-specific data)
    match /police/{policeId} {
      // ⭐ FIX: Added 'create' here so Admins/Approved Police can register new officers
      allow read, create, update, delete: if isPolice();

      // ⭐ Individual officer → own profile only (e.g., for self-registration or login)
      // CHANGED: Added 'read' so citizens can check if they are police (auth flow) and unapproved officers can see their profiles
      allow read, create: if request.auth != null &&
        request.resource.data.uid == request.auth.uid;
      
      // Note: for read, it uses resource.data, for create it uses request.resource.data.
      // Combining them in one line is tricky if fields differ, better to separate or use logic.
      // Re-separating for clarity and correctness:
      
      allow read: if request.auth != null && resource.data.uid == request.auth.uid;
      
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;

      allow update: if request.auth != null &&
        resource.data.uid == request.auth.uid;
    }

    // CASES COLLECTION (FIRs)
    match /cases/{caseId} {
      // Allow authenticated users to create a case where userId matches their uid
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;

      // Citizens: only own cases
      // Police (stored in /police/{uid} with role == 'police'): all cases
      allow read: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        // Use isPolice() OR check if the user is a police officer by querying logic if needed
        isPolice()
      );

      // Updates:
      // - Citizen owner can update their own case
      // - Approved police can update any case (to attach investigation PDFs, etc.)
      allow update: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        isPolice()
      );

      // Deletions remain restricted to the citizen owner
      allow delete: if request.auth != null &&
        resource.data.userId == request.auth.uid;
    }

    // PETITIONS COLLECTION
    match /petitions/{petitionId} {
      // Allow anyone authenticated to read petitions
      allow read: if request.auth != null;
      
      // Allow create if:
      // 1. User is authenticated AND userId matches their UID (citizen creating their own petition)
      // 2. OR user is an approved police officer (can create offline petitions for citizens)
      allow create: if request.auth != null && (
        request.resource.data.userId == request.auth.uid ||
        isPolice()
      );
      
      // Allow update if:
      // 1. User is the owner of the petition
      // 2. OR user is an approved police officer (can update any petition)
      allow update: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        isPolice()
      );
      
      // Allow delete only if user is the owner
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // PETITION COUNTERS COLLECTION
    match /petition_counters/{counterId} {
      allow read, create, update: if request.auth != null;
    }
    
    // OFFLINE PETITIONS COLLECTION (NO UNDERSCORE - matches code)
    // Collection: offlinepetitions
    // Used by police officers to submit petitions on behalf of citizens
    // and assign them to organizational units (Range, District, Station)
    match /offlinepetitions/{petitionId} {
      // Only approved police can create offline petitions
      // The assignedBy field must match the authenticated police officer's uid
      allow create: if isPolice() &&
        request.resource.data.assignedBy == request.auth.uid;

      // Read access:
      // - Any approved police officer can read offline petitions
      // - Police officers in the assigned organizational unit can read petitions assigned to them
      // - The citizen whose petition it is (based on userId) can also read it
      allow read: if request.auth != null && (
        isPolice() ||
        resource.data.userId == request.auth.uid
      );

      // Update access:
      // - The police officer who created the offline petition can update it
      // - Any approved police officer can update the petition (to change status, add notes, etc.)
      allow update: if isPolice();

      // Delete access:
      // - Only the police officer who created the offline petition can delete it
      allow delete: if isPolice() &&
        resource.data.assignedBy == request.auth.uid;
    }
    
    // SAVED COMPLAINTS COLLECTION
    // Corrected rules for full CRUD access by owner
    match /complaints/{complaintId} {
      // Allow read if user owns the complaint
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      
      // Allow create if user sets their own uid
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      
      // Allow delete if user owns the complaint
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      
      // Allow update if user owns the complaint
      allow update: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // PETITION UPDATES TIMELINE COLLECTION
    // Collection: petition_updates
    // Used by police to add progress updates on petitions with text, photos, and documents
    match /petition_updates/{updateId} {
      // Only approved police can create petition updates
      // The addedByUserId field must match the authenticated police officer's uid
      allow create: if isPolice() &&
        request.resource.data.addedByUserId == request.auth.uid;

      // Read access:
      // - Any approved police officer can read petition updates
      // - The citizen who owns the petition can read updates for their own petition
      allow read: if request.auth != null && (
        isPolice() ||
        (
          resource.data.petitionId is string &&
          exists(/databases/$(database)/documents/petitions/$(resource.data.petitionId)) &&
          get(/databases/$(database)/documents/petitions/$(resource.data.petitionId)).data.userId == request.auth.uid
        )
      );

      // Only the police officer who created the update can modify or delete it
      allow update, delete: if isPolice() &&
        resource.data.addedByUserId == request.auth.uid;
    }

    // CASE JOURNAL ENTRIES
    // Collection: caseJournalEntries
    // Used only by police in the app (CaseJournalScreen)
    match /caseJournalEntries/{entryId} {
      // Only approved police can create journal entries,
      // and the officerUid field must match their uid.
      allow create: if isPolice() &&
        request.resource.data.officerUid == request.auth.uid;

      // Read access:
      // - Any approved police officer can read journal entries
      //   (for supervisor / station-level review).
      // - The citizen who owns the underlying FIR/case can also read
      //   entries for their own case, so that evidence attachments
      //   show up under Case Details → Evidence tab.
      allow read: if
        isPolice() ||
        (
          request.auth != null &&
          resource.data.caseId is string &&
          exists(/databases/$(database)/documents/cases/$(resource.data.caseId)) &&
          get(/databases/$(database)/documents/cases/$(resource.data.caseId)).data.userId == request.auth.uid
        );

      // Only the officer who created the entry can modify/delete it.
      allow update, delete: if isPolice() &&
        resource.data.officerUid == request.auth.uid;
    }
    
    
    
    match /prompts/{promptId} {
      allow read: if isPolice();      // only admin/police can view
      allow create: if isPolice();    // only admin can add
      allow update, delete: if isPolice();
    }

    match /chargesheets/{docId} {
      allow read, create: if isPolice();
      allow update, delete: if isPolice() && resource.data.officerId == request.auth.uid;
    }


    // CRIME DETAILS COLLECTION
    // Stores detailed crime scene information for each case
    match /crimeDetails/{caseId} {
      // Police can create crime details for any case
      allow create: if isPolice();

      // Read access:
      // - Police can read all crime details
      // - Citizens can read crime details for their own cases
      allow read: if request.auth != null && (
        isPolice() ||
        (
          exists(/databases/$(database)/documents/cases/$(caseId)) &&
          get(/databases/$(database)/documents/cases/$(caseId)).data.userId == request.auth.uid
        )
      );

      // Police can update crime details
      allow update: if isPolice();

      // Only police can delete crime details
      allow delete: if isPolice();
    }

    // CASES SUBCOLLECTIONS
    match /cases/{caseId}/{subcollection}/{docId} {
      // MEDIA ANALYSES SUBCOLLECTION
      // Stores AI-powered media analysis results
      allow read: if request.auth != null && (
        isPolice() ||
        (
          exists(/databases/$(database)/documents/cases/$(caseId)) &&
          get(/databases/$(database)/documents/cases/$(caseId)).data.userId == request.auth.uid
        )
      );

      // Police can create, update, and delete media analyses
      allow create, update, delete: if isPolice();
    }

    // SCENE ANALYSES SUBCOLLECTION (NEW)
    // Stores AI-powered crime scene analysis from Gemini API
    match /cases/{caseId}/sceneAnalyses/{analysisId} {
      // Police can create scene analyses
      allow create: if isPolice();

      // Read access:
      // - Police can read all scene analyses
      // - Citizens can read analyses for their own cases
      allow read: if request.auth != null && (
        isPolice() ||
        (
          exists(/databases/$(database)/documents/cases/$(caseId)) &&
          get(/databases/$(database)/documents/cases/$(caseId)).data.userId == request.auth.uid
        )
      );

      // Police can update and delete scene analyses
      allow update, delete: if isPolice();
    }
    
    // CRIME SCENE EVIDENCE SUBCOLLECTION (for file paths persistence)
    match /cases/{caseId}/crimeSceneEvidence/{docId} {
      // Police can create and update evidence records
      allow create, update: if isPolice();

      // Read access: Police + case owner
      allow read: if request.auth != null && (
        isPolice() ||
        (
          exists(/databases/$(database)/documents/cases/$(caseId)) &&
          get(/databases/$(database)/documents/cases/$(caseId)).data.userId == request.auth.uid
        )
      );

      // Police can delete evidence records
      allow delete: if isPolice();
    }

    // LEGAL QUERIES CHATS COLLECTION
    // Collection: legal_queries_chats
    // Used by both citizens and police for AI legal consultations
    match /legal_queries_chats/{sessionId} {
      // Allow authenticated users to create their own chat sessions
      // The userId field must match the authenticated user's uid
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;

      // Users can only read their own chat sessions
      allow read: if request.auth != null &&
        resource.data.userId == request.auth.uid;

      // Users can update their own chat sessions (e.g., updating title, lastMessageAt)
      allow update: if request.auth != null &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own chat sessions
      allow delete: if request.auth != null &&
        resource.data.userId == request.auth.uid;

      // MESSAGES SUBCOLLECTION
      // Allow users to read and write messages within their own chat sessions
      match /messages/{messageId} {
        // Allow creating messages if the parent session belongs to the user
        allow create: if request.auth != null &&
          get(/databases/$(database)/documents/legal_queries_chats/$(sessionId)).data.userId == request.auth.uid;

        // Allow reading messages if the parent session belongs to the user
        allow read: if request.auth != null &&
          get(/databases/$(database)/documents/legal_queries_chats/$(sessionId)).data.userId == request.auth.uid;

        // Allow updating messages if the parent session belongs to the user
        allow update: if request.auth != null &&
          get(/databases/$(database)/documents/legal_queries_chats/$(sessionId)).data.userId == request.auth.uid;

        // Allow deleting messages if the parent session belongs to the user
        allow delete: if request.auth != null &&
          get(/databases/$(database)/documents/legal_queries_chats/$(sessionId)).data.userId == request.auth.uid;
      }
    }
    
    // FCM TOKENS COLLECTION (for push notifications)
    // Users can register and manage their own FCM device tokens
    match /fcm_tokens/{tokenId} {
      // Allow users to create their own FCM tokens
      // The userId field must match the authenticated user's uid
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;
      
      // Users can only read their own FCM tokens
      allow read: if request.auth != null &&
        resource.data.userId == request.auth.uid;
      
      // Users can update their own FCM tokens (e.g., refreshing token, marking inactive)
      allow update: if request.auth != null &&
        resource.data.userId == request.auth.uid;
      
      // Users can delete their own FCM tokens
      allow delete: if request.auth != null &&
        resource.data.userId == request.auth.uid;
    }
    
  }
}